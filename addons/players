--!strict

--[[very simple usage example
local exampleGroup = QuickBounds.createGroup()

local zone = QuickBounds.createZoneFromInstance(workspace.ExampleZone)
zone:watchGroups(exampleGroup)

game.Players.PlayerAdded:Connect(function(player)
	PlayerAddon.addPlayerToGroups(player, exampleGroup)
end)

exampleGroup:onEntered(function(rootPart, zone, player: Player)
	print(player, "entered zone", zone.part)
end)

exampleGroup:onExited(function(rootPart, zone, player: Player)
	print(player, "exited zone", zone.part)
end)
]]

local Players = game:GetService("Players")
local ReplicatedStorage = game:GetService("ReplicatedStorage")

local QuickBounds = require(ReplicatedStorage.QuickBounds)

local characterAddedConnections: {[Player]: RBXScriptConnection} = {}
local characterRemovingConnections: {[Player]: RBXScriptConnection} = {}

local playerToGroups: {[Player]: {QuickBounds.Group}} = {}

type Character = Model & {HumanoidRootPart: BasePart?}

local function findGroupIndexByUID(groups: {QuickBounds.Group}, UID: number): number?
	for index, group in groups do
		if group.UID == UID then
			return index
		end
	end
	return nil
end

local function addToGroups(player: Player, root: BasePart): ()
	local playerGroups = playerToGroups[player]
	for _, group in playerGroups do
		group:add(root, player)
	end
end

local function removeFromGroups(player: Player, root: BasePart): ()
	local playerGroups = playerToGroups[player]
	for _, group in playerGroups do
		group:remove(root)
	end
end

local function addPlayerToGroups(player: Player, ...: QuickBounds.Group): ()
	if not playerToGroups[player] then
		playerToGroups[player] = {}
	end

	if not characterAddedConnections[player] then
		characterAddedConnections[player] = player.CharacterAdded:Connect(function(character)
			if not (character :: Character).HumanoidRootPart then
				error("[CharacterAdded] " .. player.Name .. " has no HumanoidRootPart")
			end

			addToGroups(player, (character :: Character).HumanoidRootPart :: BasePart)
		end)
		characterRemovingConnections[player] = player.CharacterRemoving:Connect(function(character)
			if not (character :: Character).HumanoidRootPart then
				error("[CharacterRemoving] " .. player.Name .. " has no HumanoidRootPart")
			end

			removeFromGroups(player, (character :: Character).HumanoidRootPart :: BasePart)
		end)
	end

	local playerGroups = playerToGroups[player]
	for _, group in {...} do
		table.insert(playerGroups, group)
	end

	local root = player.Character and (player.Character :: Character).HumanoidRootPart
	if root then
		addToGroups(player, root)
	end
end

local function removePlayerFromGroups(player: Player, ...: QuickBounds.Group)
	local root = player.Character and (player.Character :: Character).HumanoidRootPart
	if not playerToGroups[player] then
		return
	end

	if not root then
		error("could not remove groups from " .. player.Name .. " because player does not have a HumanoidRootPart")
	end

	local playerGroups = playerToGroups[player]

	for _, group in {...} do
		local index = findGroupIndexByUID(playerGroups, group.UID)
		if index then
			table.remove(playerGroups, index)
		end

		group:remove(root)
	end

	if #playerGroups == 0 then
		playerToGroups[player] = nil
	end
end

Players.PlayerRemoving:Connect(function(player)
	characterAddedConnections[player] = nil
	characterRemovingConnections[player] = nil
	playerToGroups[player] = nil
end)

return {
	addPlayerToGroups = addPlayerToGroups,
	removePlayerFromGroups = removePlayerFromGroups
}